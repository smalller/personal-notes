## 二分查找

二分查找最多需要的次数为：logn次
如：
列表有32个元素，最多需要4次
列表有100个元素，最多需要7次
列表有40亿个元素，最多需要32次
使用二分查找的前提是列表必须是有序的时候

简单的查找，100个元素，最多需要100次，这种被称为线性时间，列表越长，需要的次数就越多

二分查找的运行时间为对数时间（或log时间）

## 大O表示法：
大O表示法没有单位，就表示运行时间为O(n)，n为操作数，即为需要的执行次数
检查长度为n的列表
简单查找需要执行n次，运行时间为O(n)；
二分查找需要执行logn（log2n）次操作，运行时间为：O(logn)
如：
查找100个元素
简单查找，运行时间为O(100)
二分查找，运行时间为O(log100)，即O(7)

## 常见的大O运行时间
从快到慢的顺序
- O(logn),也叫对数时间，算法包括二分查找
- O(n),也叫线性时间，算法包括简单查找
- O(n * logn),算法包括快速排序（一种速度比较快的排序算法）
- O(n^2),算法包括选择排序（一种速度较慢的排序算法）
- O(n!),n的阶乘，一种非常慢的算法

## 启示
- 算法的速度指的并非时间，而是操作数的增速
- 谈论算法的速度时，说的是随着输入的增加，其运行时间将以什么样的速度增加
- 算法的运行时间用大O表示法表示
- O(logn)比O(n)快，当搜索的元素越多时，前者比后者快更多
- 算法运行时间是从其增速的角度度量的

## 数组与链表
- 需要随机读取元素时，数组的效率很高，因为数组知道每个元素的位置，可以迅速找到数组中的任何元素
- 在链表中，无法迅速计算出任意一个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推

### 数组和链表操作的运行时间
| | 数组 | 链表 |
| --- | --- | --- | --- |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

### 选择
- 执行的插入操作很多，但读取操作较少，该使用链表
- 当需要在中间插入元素时，该使用链表
- 删除元素时，也该使用链表，因为链表只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素向前移 


## 递归
- 栈有2种操作：压入和弹出
- 所有函数调用都进入调用栈
- 调用栈可能很长，将占用大量的内存

## 快速排序
分而治之（D&C）:一种著名的递归式问题解决方案
快速排序属于D&C中的一种算法，是最开的排序算法之一，也是D&C的典范

D&C的工作原理
- 找出简单的基线条件
- 确定如何缩小问题的规模，使其符合基线条件

D&C并非可用于解决问题的算法，而是一种解决问题的思路

快速排序步骤：
- 选择基准值
- 将数组分成两个子数组：小于基准值的元素组成的子数组和大于基准值的元素组成的子数组
- 对这两个子数组进行快速排序
- 合并数组

快速排序调用栈的高度为O(logn)，而每层需要的时间为O(n)，因此该算法的运行时间为O(n)\*O(logn)=O(n\*logn)，这是最佳情况下；最糟情况下，调用栈的高度为O(n)，因此运行时间为O(n)*O(n)=O(n^2)。其实最佳情况也是平均情况

## 散列表
散列表也被称为散列映射、映射、字典和关联数组
- 散列函数总是将同样的输入映射到相同的索引，每次输入一个值，得到的都是同一个数字。首先你要确定将一个值存储在什么地方，并在以后都使用这个值来确定它存储在什么地方
- 散列函数将不同的输入映射到不同的索引，不会重复
- 散列函数知道数组有多大，只返回有效索引

### 小结：
- 可以结合散列函数和数组来创建散列表
- 应使用可以最大限度减少冲突的散列函数
- 散列表的查找、插入和删除速度都非常快
- 散列表使用于模拟映射关系
- 一旦填充因子超过0.7，就应该调整散列表的长度
- 散列表可用于缓存数据
- 散列表非常适合用于防止重复

## 广度优先搜索
### 图
- 图由节点和边组成
- 一个节点可能与众多节点直接相连，这些节点被称为邻居

### 队列
- 不能随机地访问队列中的元素
- 队列只支持入队和出队两种操作
- 是一种先进先出的数据结构

### 栈
- 是一种先进后出的数据结构

### 小结
- 广度优先搜索指出是否有才从A到B的路径
- 如果有，广度优先搜索将找出最短路径
- 面临类似寻找最短路径的问题时，可尝试使用图来建立模型
- 有向图中的边为箭头，箭头的方向指定了关系的方向
- 无向图中的边不带箭头，其中的关系是双向的
- 队列是先进先出
- 栈是先进后出
- 需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因为搜索列表必须是队列
- 对于检查过的人，务必不要再去检查，否则可能导致无限循环

## 狄克斯特拉算法
步骤：
- 找出“最便宜”的节点，即可在最短时间内到达的节点
- 更新该节点的邻居的开销
- 重复这个过程，直到对图中的每个节点都这样做了
- 计算最终路径（每个最便宜的节点所需时间相加）

### 术语
- 狄克斯特拉算反用于每条边都有关联数字的图，这些数字称为权重
- 带权重的图称为加权图，不带权重的图称为非加权图
- 要计算非加权图的最短路径，可使用广度优先搜索
- 要计算加权图中的最短路径，可使用迪狄斯特拉算法
- 最短路径指的并不一定是物理距离，也可能是让某种度量指标最小

### 小结
- 广度优先搜索用于在非加权图中查找最短路径
- 狄克斯特拉算法用于在加权图中查找最短路径
- 仅当权重为正时，狄克斯特拉算法才管用
- 如果图中包含负权边，就使用贝尔曼福德算法

## NP完全问题
- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢
- 设计“所有数组”的问题通常是NP完全问题
- 不能将问题分成小问题，必须考虑各种可能的情况，这可能是NP完全问题
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，他可能就是NP完全问题
- 如果问题涉及集合（如广播台集合）且难以解决，他可能就是NP完全问题
- 如果问题可转换为集合覆盖问题或旅行商问题，那他肯定是NP完全问题

### 小结
- 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解
- 对于NP完全问题，还没有找到快速解决方案
- 面临NP完全问题，最佳的做法就是使用近似算法
- 贪婪算法易于实现，运行速度快，是不错的近似算法

## 动态规划启示
- 动态规划可在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品
- 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决
- 每种动态规划解决方案都涉及网格
- 单元格中的值通常就是你要优化的值。在背包问题中，单元格的值为商品的价值
- 每个单元格都是一个子问题，因此你应该考虑如何将问题分成子问题，这有助于你找出网格的坐标轴

### 小结
- 需要在给定约束条件下优化某种指标时，动态规划很有用
- 问题可分解为离散子问题时，可使用动态规划来解决
- 每种动态规划解决方案都涉及网格
- 单元格中的值都通常就是你要优化的值
- 每个单元格都是一个子问题，因为你需要考虑如何将问题分解为子问题
- 没有放之四海皆准的计算动态规划解决方案的公式

## K最近邻算法
- KNN用于分类和回归，需要考虑最近的邻居
- 分类就是编组
- 回归就是预测结果
- 特征抽取意味着将物品转换成一系列可比较的数字
- 能否挑选合适的特征事关KNN算法的成败

## 二叉树
- 查找节点时，平均运行时间为O(logn)，但在最遭的情况下所需时间为O(n)
- 而在有序数组中查找时，最糟情况下所需时间也只有O(logn)
- 二叉树的插入和删除操作的速度要比有序数组快得多
- 二叉树不能随机访问，在二叉树处于平衡状态时，平均访问时间也为O(logn)